<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Meeting Room</title>
<script src="/socket.io/socket.io.js"></script>
<style>
  body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: #181818;
    color: #fff;
    display: flex;
    flex-direction: column;
    height: 100vh;
  }

  header {
    background: #202020;
    padding: 8px 12px;
    text-align: center;
    font-size: 18px;
    font-weight: 600;
  }
  #meetingTimer { font-weight: normal; color: #0f9d58; margin-left: 10px; }

  #top-strip {
    display: flex;
    gap: 10px;
    background: #111;
    padding: 8px;
    overflow-x: auto;
    scrollbar-width: thin;
  }
  .small-tile {
    flex: 0 0 120px;
    height: 90px;
    background: #2a2a2a;
    border-radius: 8px;
    position: relative;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .small-tile video, .small-tile img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  .name-label {
    position: absolute;
    bottom: 5px; left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.6);
    padding: 2px 6px;
    border-radius: 12px;
    font-size: 12px;
  }

  #main-speaker {
    flex: 1;
    display: flex;
    background: #000;
    justify-content: center;
    align-items: center;
    position: relative;
  }
  #main-speaker video, #main-speaker img {
    max-width: 95%;
    max-height: 95%;
    border-radius: 10px;
    background: #000;
    object-fit: cover;
  }
  #main-speaker .name-label {
    top: 10px;
    bottom: auto;
    background: rgba(0,0,0,0.7);
  }

  footer {
    background: #202020;
    padding: 8px 0;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 16px;
  }
  footer button {
    background: transparent;
    border: none;
    color: #fff;
    font-size: 18px;
    cursor: pointer;
    padding: 8px 14px;
    border-radius: 6px;
  }
  footer button:hover { background: rgba(255,255,255,0.1); }
  .end-btn {
    background: #cc1534;
    border-radius: 20px;
    font-weight: bold;
  }

  #chatbox {
    position: absolute;
    right: 10px;
    bottom: 60px;
    width: 250px;
    height: 250px;
    background: #fff;
    color: #000;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  #chat-messages {
    flex: 1;
    padding: 6px;
    overflow-y: auto;
    font-size: 13px;
  }
  #chat-input {
    display: flex;
    border-top: 1px solid #ccc;
  }
  #chat-input input {
    flex: 1;
    padding: 6px;
    border: none;
    outline: none;
  }
  #chat-input button {
    background: #6a0dad;
    border: none;
    color: #fff;
    padding: 0 10px;
    cursor: pointer;
  }
</style>
</head>
<body>

<header>
  Meeting Room
  <span id="meetingTimer">00:00:00</span>
</header>

<div id="top-strip"></div>

<div id="main-speaker">
  <div class="name-label" id="mainSpeakerName"></div>
</div>

<footer>
  <button id="muteBtn">üé§ Mute</button>
  <button id="videoBtn">üì∑ Stop Video</button>
  <button id="screenBtn">üñ•Ô∏è Share Screen</button>
  <button id="avatarBtn">üßë Avatar</button>
  <button id="leaveBtn" class="end-btn">End Meeting</button>
</footer>

<div id="chatbox">
  <div id="chat-messages"></div>
  <div id="chat-input">
    <input type="text" id="chatText" placeholder="Type a message...">
    <button id="sendChat">Send</button>
  </div>
</div>

<script>
const socket = io();
const params = new URLSearchParams(window.location.search);
const roomId = params.get('room') || 'default';
let name = params.get('name') || prompt("Enter your name:") || "Guest";
const useAvatar = params.get('useAvatar') === 'true';
const savedAvatar = localStorage.getItem('userAvatar');

let localStream;
const peers = {};
let meetingTranscript = ""; // üìù store speech text for summary

const rtcConfig = {
  iceServers: [
    { urls: ["stun:bn-turn1.xirsys.com"] },
    {
      username: "9vPc46D2ulxFRkRBW-g2drEOHQp3FYwqstrpoR1Ar-SRTS3NmWDUuFDl33686Tu0AAAAAGjiKYtzeWVkYW5heml5YQ==",
      credential: "b4003654-a1c3-11f0-a3eb-0242ac140004",
      urls: [
        "turn:bn-turn1.xirsys.com:80?transport=udp",
        "turn:bn-turn1.xirsys.com:3478?transport=udp",
        "turn:bn-turn1.xirsys.com:80?transport=tcp",
        "turn:bn-turn1.xirsys.com:3478?transport=tcp",
        "turns:bn-turn1.xirsys.com:443?transport=tcp",
        "turns:bn-turn1.xirsys.com:5349?transport=tcp"
      ]
    }
  ]
};

const mainSpeaker = document.getElementById('main-speaker');
const topStrip = document.getElementById('top-strip');
const timerDisplay = document.getElementById('meetingTimer');

// ---------------- Timer ----------------
const startTime = Date.now();
setInterval(()=> {
  const elapsed = Date.now() - startTime;
  const h = Math.floor(elapsed/3600000);
  const m = Math.floor((elapsed%3600000)/60000);
  const s = Math.floor((elapsed%60000)/1000);
  timerDisplay.textContent =
    `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
},1000);

// ---------------- UI Helpers ----------------
function createSmallTile(id,label,stream,avatarURL){
  let tile = document.getElementById('tile-'+id);
  if(!tile){
    tile = document.createElement('div');
    tile.className = 'small-tile';
    tile.id = 'tile-'+id;

    if(stream){
      const video = document.createElement('video');
      video.autoplay = true;
      video.playsInline = true;
      if(id==='me') video.muted = true;
      video.srcObject = stream;
      tile.appendChild(video);
    } else if(avatarURL){
      const img = document.createElement('img');
      img.src = avatarURL;
      tile.appendChild(img);
    }

    const lbl = document.createElement('div');
    lbl.className = 'name-label';
    lbl.textContent = label;
    tile.appendChild(lbl);
    topStrip.appendChild(tile);
  } else {
    if(stream){
      tile.innerHTML = `<video autoplay playsinline ${id==='me'?'muted':''}></video>
                        <div class="name-label">${label}</div>`;
      tile.querySelector('video').srcObject = stream;
    } else if(avatarURL){
      tile.innerHTML = `<img src="${avatarURL}">
                        <div class="name-label">${label}</div>`;
    }
  }
}

function setMainSpeaker(id,label,stream,avatarURL){
  if(stream){
    mainSpeaker.innerHTML = `<video autoplay playsinline ${id==='me'?'muted':''}></video>
      <div class="name-label">${label}</div>`;
    mainSpeaker.querySelector('video').srcObject = stream;
  } else if(avatarURL){
    mainSpeaker.innerHTML = `<img src="${avatarURL}">
      <div class="name-label">${label}</div>`;
  }
}

// ---------------- Media ----------------
async function initMedia(){
  try{
    if(useAvatar && savedAvatar){
      createSmallTile('me', name + ' (Avatar)', null, savedAvatar);
      setMainSpeaker('me', name + ' (Avatar)', null, savedAvatar);
      socket.emit("set-avatar", { roomId, avatar: savedAvatar, name });
      startSpeechRecognition(); // üé§ start speech-to-text when avatar is active
    } else {
      localStream = await navigator.mediaDevices.getUserMedia({video:true,audio:true});
      createSmallTile('me', name + ' (You)', localStream, null);
      setMainSpeaker('me', name + ' (You)', localStream, null);
    }
  }catch(e){ alert("Camera/Mic error: "+e); }
}

// ---------------- Speech-to-Text ----------------
let recognition;
function startSpeechRecognition(){
  if(!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)){
    console.warn("Speech recognition not supported in this browser.");
    return;
  }
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  recognition = new SpeechRecognition();
  recognition.lang = 'en-IN';
  recognition.continuous = true;
  recognition.interimResults = true;

  recognition.onresult = (e) => {
    for(let i=e.resultIndex;i<e.results.length;i++){
      if(e.results[i].isFinal){
        meetingTranscript += e.results[i][0].transcript + ". ";
      }
    }
  };
  recognition.onerror = (err)=>console.error("STT Error:", err);
  recognition.start();
}

// ---------------- Peers ----------------
function createPeerConnection(peerId){
  const pc = new RTCPeerConnection(rtcConfig);
  if(localStream){
    localStream.getTracks().forEach(t=>pc.addTrack(t,localStream));
  }
  pc.ontrack = e=>{
    createSmallTile(peerId,'User '+peerId.slice(0,5),e.streams[0],null);
    setMainSpeaker(peerId,'User '+peerId.slice(0,5),e.streams[0],null);
  };
  pc.onicecandidate = e=>{
    if(e.candidate) socket.emit('webrtc-ice-candidate',{to:peerId,candidate:e.candidate});
  };
  pc.onconnectionstatechange=()=>{
    if(['disconnected','failed','closed'].includes(pc.connectionState)){
      const tile=document.getElementById('tile-'+peerId);
      if(tile) tile.remove();
      pc.close(); delete peers[peerId];
    }
  };
  peers[peerId]=pc;
  return pc;
}

async function callPeer(peerId){
  const pc = createPeerConnection(peerId);
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  socket.emit('webrtc-offer',{to:peerId,sdp:offer});
}

// ---------------- Socket Events ----------------
socket.on('connect',async()=>{
  await initMedia();
  socket.emit('join-room',{roomId,name});
});

socket.on('existing-peers',async({peers:existing})=>{
  for(const p of existing) await callPeer(p);
});

socket.on('peer-joined',({peerId})=>console.log("Peer joined:",peerId));

socket.on('webrtc-offer',async({from,sdp})=>{
  const pc=createPeerConnection(from);
  await pc.setRemoteDescription(new RTCSessionDescription(sdp));
  const answer=await pc.createAnswer();
  await pc.setLocalDescription(answer);
  socket.emit('webrtc-answer',{to:from,sdp:answer});
});

socket.on('webrtc-answer',async({from,sdp})=>{
  const pc=peers[from]; if(pc) await pc.setRemoteDescription(new RTCSessionDescription(sdp));
});

socket.on('webrtc-ice-candidate',async({from,candidate})=>{
  const pc=peers[from]; if(pc && candidate) await pc.addIceCandidate(new RTCIceCandidate(candidate));
});

socket.on('peer-left',({peerId})=>{
  const tile=document.getElementById('tile-'+peerId);
  if(tile) tile.remove();
  if(peers[peerId]) peers[peerId].close();
  delete peers[peerId];
});

socket.on("peer-avatar", ({ peerId, avatar, name }) => {
  createSmallTile(peerId, name + " (Avatar)", null, avatar);
  setMainSpeaker(peerId, name + " (Avatar)", null, avatar);
});

// ---------------- Controls ----------------
document.getElementById('muteBtn').onclick=()=>{
  if(localStream){
    const t = localStream.getAudioTracks()[0];
    if(t){ t.enabled = !t.enabled; }
  }
};

document.getElementById('videoBtn').onclick=()=>{
  if(localStream){
    const t = localStream.getVideoTracks()[0];
    if(t){ t.enabled = !t.enabled; }
  }
};

document.getElementById('screenBtn').onclick=async()=>{
  try{
    const screen=await navigator.mediaDevices.getDisplayMedia({video:true});
    const track=screen.getVideoTracks()[0];
    for(const pc of Object.values(peers)){
      const sender=pc.getSenders().find(s=>s.track.kind==='video');
      if(sender) sender.replaceTrack(track);
    }
    setMainSpeaker('me',name+' (You)',screen,null);
    track.onended=()=>{
      if(localStream){
        const camTrack=localStream.getVideoTracks()[0];
        for(const pc of Object.values(peers)){
          const sender=pc.getSenders().find(s=>s.track.kind==='video');
          if(sender) sender.replaceTrack(camTrack);
        }
        setMainSpeaker('me',name+' (You)',localStream,null);
      }
    };
  }catch(e){ console.log("Screen share cancelled."); }
};

document.getElementById('avatarBtn').onclick=()=>{
  window.location.href = `avatar.html?room=${encodeURIComponent(roomId)}&name=${encodeURIComponent(name)}`;
};
// add this function near the top <script>
async function saveMeetingSummary(title, summary) {
  try {
    const res = await fetch('/save-summary', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title, summary })
    });
    const data = await res.json();
    console.log('üì© Save summary response:', data);
  } catch (err) {
    console.error('‚ùå Failed to save summary:', err);
  }
}

// modify leave button
document.getElementById('leaveBtn').onclick = async () => {
  const title = prompt("Enter meeting title:") || "Untitled Meeting";
  const summary = "This is a test summary because speech-to-text is not added yet.";

  await saveMeetingSummary(title, summary);

  Object.values(peers).forEach(pc => pc.close());
  if(localStream) localStream.getTracks().forEach(t => t.stop());
  window.location.href = '/index.html';
};


document.getElementById('leaveBtn').onclick=()=>{
  if(recognition) recognition.stop(); // stop STT
  Object.values(peers).forEach(pc=>pc.close());
  if(localStream) localStream.getTracks().forEach(t=>t.stop());

  // üî• Save transcript summary if avatar mode
  if(meetingTranscript.trim().length > 0){
    fetch("/save-summary", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ meetingId: roomId, transcript: meetingTranscript })
    }).then(res=>res.json())
      .then(data=>console.log("Summary saved:", data))
      .catch(err=>console.error("Save summary error:", err));
  }

  window.location.href='/index.html';
};

// ---------------- Chat ----------------
const chatMessages=document.getElementById('chat-messages');
const chatInput=document.getElementById('chatText');
document.getElementById('sendChat').onclick=()=>{
  const msg=chatInput.value.trim();
  if(!msg) return;
  socket.emit('chat-message',{roomId,name,message:msg});
  chatInput.value='';
};
socket.on('chat-message',({name:sender,message})=>{
  const d=document.createElement('div');
  d.textContent=`${sender}: ${message}`;
  chatMessages.appendChild(d);
  chatMessages.scrollTop=chatMessages.scrollHeight;
});
</script>
</body>
</html>
