<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Meeting Room | Professional Video Conference</title>
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<style>
  :root {
    --primary-color: #0f9d58;
    --secondary-color: #4285f4;
    --danger-color: #cc1534;
    --dark-bg: #181818;
    --darker-bg: #111;
    --card-bg: #2a2a2a;
    --text-light: #ffffff;
    --text-muted: #aaaaaa;
    --border-radius: 8px;
  }

  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: var(--dark-bg);
    color: var(--text-light);
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
  }

  /* Header */
  header {
    background: var(--darker-bg);
    padding: 12px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #333;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
  }

  .header-left {
    display: flex;
    align-items: center;
    gap: 15px;
  }

  .logo {
    font-weight: 700;
    font-size: 20px;
    color: var(--primary-color);
  }

  #meetingTimer {
    font-weight: 600;
    color: var(--primary-color);
    background: rgba(15, 157, 88, 0.1);
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 14px;
  }

  .header-right {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  /* Recording indicator */
  .recording-indicator {
    background: var(--danger-color);
    color: white;
    padding: 6px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 6px;
    animation: pulse 1.5s infinite;
  }

  @keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
  }

  /* MEMO Button */
  #memoBtn {
    background: var(--secondary-color);
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 20px;
    font-weight: 600;
    font-size: 14px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.2s ease;
  }

  #memoBtn:hover {
    background: #3367d6;
    transform: translateY(-1px);
  }

  #memoBtn.recording {
    background: var(--danger-color);
  }

  /* Main layout */
  .meeting-container {
    display: flex;
    flex: 1;
    overflow: hidden;
  }

  /* Participants strip */
  #top-strip {
    display: flex;
    gap: 10px;
    background: var(--darker-bg);
    padding: 12px;
    overflow-x: auto;
    scrollbar-width: thin;
    border-bottom: 1px solid #333;
    min-height: 120px;
  }

  .small-tile {
    flex: 0 0 160px;
    height: 100px;
    background: var(--card-bg);
    border-radius: var(--border-radius);
    position: relative;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: all 0.2s ease;
    border: 2px solid transparent;
  }

  .small-tile:hover {
    border-color: var(--primary-color);
    transform: scale(1.02);
  }

  .small-tile.active {
    border: 2px solid var(--primary-color);
    box-shadow: 0 0 10px rgba(15, 157, 88, 0.3);
  }

  .small-tile video, .small-tile img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .name-label {
    position: absolute;
    bottom: 5px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 500;
    max-width: 90%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Main speaker area */
  #main-speaker {
    flex: 1;
    display: flex;
    background: #000;
    justify-content: center;
    align-items: center;
    position: relative;
    overflow: hidden;
  }

  #main-speaker video, #main-speaker img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    background: #000;
  }

  #main-speaker .name-label {
    top: 15px;
    bottom: auto;
    background: rgba(0,0,0,0.8);
    padding: 6px 12px;
    font-size: 14px;
  }

  /* Controls footer */
  footer {
    background: var(--darker-bg);
    padding: 15px 0;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    border-top: 1px solid #333;
  }

  .control-btn {
    background: rgba(255,255,255,0.1);
    border: none;
    color: var(--text-light);
    font-size: 16px;
    cursor: pointer;
    padding: 10px 16px;
    border-radius: var(--border-radius);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    transition: all 0.2s ease;
    min-width: 80px;
  }

  .control-btn:hover {
    background: rgba(255,255,255,0.2);
    transform: translateY(-2px);
  }

  .control-btn.active {
    background: var(--primary-color);
  }

  .control-btn .btn-label {
    font-size: 12px;
    font-weight: 500;
  }

  .end-btn {
    background: var(--danger-color);
    border-radius: 20px;
    font-weight: bold;
    padding: 10px 24px;
  }

  .end-btn:hover {
    background: #b3122f;
  }

  /* Chat panel */
  #chatbox {
    position: absolute;
    right: 20px;
    bottom: 80px;
    width: 350px;
    height: 400px;
    background: #fff;
    color: #000;
    border-radius: var(--border-radius);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 0 5px 25px rgba(0,0,0,0.3);
    z-index: 1000;
    border: 1px solid #ddd;
  }

  .chat-header {
    background: var(--secondary-color);
    color: white;
    padding: 10px 15px;
    font-weight: 600;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .close-chat {
    background: none;
    border: none;
    color: white;
    font-size: 18px;
    cursor: pointer;
  }

  #chat-messages {
    flex: 1;
    padding: 10px;
    overflow-y: auto;
    font-size: 14px;
    background: #f9f9f9;
  }

  .chat-message {
    margin-bottom: 10px;
    padding: 8px;
    border-radius: 6px;
    background: white;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }

  .chat-sender {
    font-weight: 600;
    color: var(--secondary-color);
    font-size: 12px;
    margin-bottom: 3px;
  }

  .chat-time {
    font-size: 10px;
    color: #666;
    float: right;
  }

  #chat-input-container {
    display: flex;
    border-top: 1px solid #ddd;
    background: white;
    padding: 8px;
    gap: 5px;
  }

  #chat-input {
    flex: 1;
    display: flex;
    gap: 5px;
  }

  #chatText {
    flex: 1;
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 20px;
    outline: none;
    font-size: 14px;
  }

  #emojiBtn {
    background: none;
    border: none;
    font-size: 18px;
    cursor: pointer;
    padding: 0 8px;
    border-radius: 50%;
    transition: background 0.2s;
  }

  #emojiBtn:hover {
    background: #f0f0f0;
  }

  #sendChat {
    background: var(--secondary-color);
    border: none;
    color: #fff;
    padding: 8px 16px;
    border-radius: 20px;
    cursor: pointer;
    font-weight: 600;
    font-size: 12px;
  }

  /* Emoji Picker */
  #emojiPicker {
    position: absolute;
    bottom: 60px;
    right: 20px;
    background: white;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 10px;
    display: none;
    flex-wrap: wrap;
    gap: 5px;
    width: 200px;
    max-height: 150px;
    overflow-y: auto;
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    z-index: 1001;
  }

  .emoji {
    font-size: 18px;
    cursor: pointer;
    padding: 5px;
    border-radius: 4px;
    transition: background 0.2s;
  }

  .emoji:hover {
    background: #f0f0f0;
  }

  /* MEMO Panel */
  #memoPanel {
    position: absolute;
    left: 20px;
    bottom: 80px;
    width: 400px;
    height: 400px;
    background: white;
    color: #000;
    border-radius: var(--border-radius);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 0 5px 25px rgba(0,0,0,0.3);
    z-index: 1000;
    border: 1px solid #ddd;
  }

  .memo-header {
    background: var(--primary-color);
    color: white;
    padding: 12px 15px;
    font-weight: 600;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .memo-controls {
    display: flex;
    gap: 8px;
  }

  .memo-control-btn {
    background: rgba(255,255,255,0.2);
    border: none;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
  }

  .memo-control-btn:hover {
    background: rgba(255,255,255,0.3);
  }

  #memoContent {
    flex: 1;
    padding: 15px;
    overflow-y: auto;
    font-size: 14px;
    line-height: 1.5;
    background: #f9f9f9;
    white-space: pre-wrap;
    font-family: 'Courier New', monospace;
  }

  .memo-entry {
    margin-bottom: 10px;
    padding: 8px;
    border-left: 3px solid var(--primary-color);
    background: white;
    border-radius: 0 4px 4px 0;
  }

  .memo-time {
    font-size: 11px;
    color: #666;
    margin-bottom: 3px;
    font-weight: 600;
  }

  .memo-speaker {
    font-weight: 600;
    color: var(--secondary-color);
  }

  .close-memo {
    background: none;
    border: none;
    color: white;
    font-size: 18px;
    cursor: pointer;
  }

  /* Responsive design */
  @media (max-width: 768px) {
    .meeting-container {
      flex-direction: column;
    }
    
    #top-strip {
      min-height: 80px;
    }
    
    .small-tile {
      flex: 0 0 100px;
      height: 70px;
    }
    
    footer {
      gap: 10px;
    }
    
    .control-btn {
      min-width: 60px;
      padding: 8px 12px;
      font-size: 14px;
    }
    
    #chatbox, #memoPanel {
      width: 90%;
      left: 5%;
      right: 5%;
    }
  }
</style>
</head>
<body>

<header>
  <div class="header-left">
    <div class="logo">TwinTalk</div>
    <div id="meetingTimer">00:00:00</div>
  </div>
  <div class="header-right">
    <div class="recording-indicator" id="recordingIndicator" style="display: none;">
      <span>üî¥</span>
      <span>Recording</span>
    </div>
    <button id="memoBtn">
      <span>üìù</span>
      <span>MEMO</span>
    </button>
  </div>
</header>

<div class="meeting-container">
  <div id="top-strip"></div>
  <div id="main-speaker">
    <div class="name-label" id="mainSpeakerName"></div>
  </div>
</div>

<footer>
  <button class="control-btn" id="muteBtn">
    <span>üé§</span>
    <span class="btn-label">Mute</span>
  </button>
  <button class="control-btn" id="videoBtn">
    <span>üì∑</span>
    <span class="btn-label">Video</span>
  </button>
  <button class="control-btn" id="screenBtn">
    <span>üñ•Ô∏è</span>
    <span class="btn-label">Share</span>
  </button>
  <button class="control-btn" id="avatarBtn">
    <span>üßë</span>
    <span class="btn-label">Avatar</span>
  </button>
  <button class="control-btn" id="chatBtn">
    <span>üí¨</span>
    <span class="btn-label">Chat</span>
  </button>
  <button class="control-btn" id="recordBtn">
    <span>‚è∫Ô∏è</span>
    <span class="btn-label">Record</span>
  </button>
  <button class="control-btn end-btn" id="leaveBtn">
    <span>üìû</span>
    <span class="btn-label">Leave</span>
  </button>
</footer>

<!-- Chat Panel -->
<div id="chatbox" style="display: none;">
  <div class="chat-header">
    <span>Chat</span>
    <button class="close-chat">‚úï</button>
  </div>
  <div id="chat-messages"></div>
  <div id="chat-input-container">
    <div id="chat-input">
      <input type="text" id="chatText" placeholder="Type a message...">
      <button id="emojiBtn">üòä</button>
    </div>
    <button id="sendChat">Send</button>
  </div>
</div>

<!-- Emoji Picker -->
<div id="emojiPicker">
  <!-- Emojis will be populated by JavaScript -->
</div>

<!-- MEMO Panel -->
<div id="memoPanel" style="display: none;">
  <div class="memo-header">
    <span>Meeting MEMO</span>
    <div class="memo-controls">
      <button class="memo-control-btn" id="saveMemo">Save</button>
      <button class="memo-control-btn" id="clearMemo">Clear</button>
      <button class="close-memo">‚úï</button>
    </div>
  </div>
  <div id="memoContent"></div>
</div>

<!-- Firebase Auth -->
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";

// Supabase client (for summaries)
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const firebaseConfig = {
  apiKey: "AIzaSyBcrgAsbXlBtL_YQHMCqE4ppYODOInTB0g",
  authDomain: "twintalk-35672.firebaseapp.com",
  projectId: "twintalk-35672",
  storageBucket: "twintalk-35672.firebasestorage.app",
  messagingSenderId: "373581191413",
  appId: "1:373581191413:web:f3bb95f18f20dfe62b4dbc",
  measurementId: "G-CJMY9LJZ7Q"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);

const SUPABASE_URL = "https://qdaegqzevidezclgvpcz.supabase.co";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFkYWVncXpldmlkZXpjbGd2cGN6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI1ODYyNDEsImV4cCI6MjA3ODE2MjI0MX0.jc7lubD4JhJWmYiHr6gy2hb-up4-cANI47DdDm7wrO0";
window.supabaseClient = createClient(SUPABASE_URL, SUPABASE_KEY);

window.saveSummaryToSupabase = async function (meetingId, transcript, userEmail) {
  try {
    const { error } = await window.supabaseClient
      .from("summaries")
      .insert([{ user_email: userEmail, meeting_id: meetingId, summary: transcript }]);
    if (error) throw error;
    console.log("‚úÖ Summary saved for", userEmail);
  } catch (e) {
    console.error("‚ùå Supabase save failed:", e);
  }
};

onAuthStateChanged(auth, (user) => {
  if (!user) {
    sessionStorage.setItem("postLoginRedirect", window.location.pathname + window.location.search);
    window.location.href = "/auth.html";
  } else startMeeting(user);
});

async function startMeeting(user) {
  const socket = io();
  const params = new URLSearchParams(window.location.search);
  const roomId = params.get("room") || "default";
  const name = user.displayName || (user.email ? user.email.split("@")[0] : "Guest");
  const userEmail = (user.email || "unknown").toLowerCase();
  const savedAvatar = localStorage.getItem("userAvatar");

  let localStream, recognition, originalVideoTrack;
  let avatarMode = false;
  const peers = {};
  const peerNames = {};
  const peerStreams = {};
  let currentMainSpeaker = "me";

  // Enhanced meeting transcript system
  let meetingTranscript = "";
  let isRecording = false;
  const recordingIndicator = document.getElementById('recordingIndicator');
  const memoBtn = document.getElementById('memoBtn');
  const memoPanel = document.getElementById('memoPanel');
  const memoContent = document.getElementById('memoContent');

  // Meeting timer
  const timerDisplay = document.getElementById("meetingTimer");
  const startTime = Date.now();
  setInterval(() => {
    const elapsed = Date.now() - startTime;
    const h = Math.floor(elapsed / 3600000);
    const m = Math.floor((elapsed % 3600000) / 60000);
    const s = Math.floor((elapsed % 60000) / 1000);
    timerDisplay.textContent = `${String(h).padStart(2,"0")}:${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
  }, 1000);

  // Initialize Chat functionality
  function initializeChat() {
    const chatBtn = document.getElementById('chatBtn');
    const chatbox = document.getElementById('chatbox');
    const closeChat = document.querySelector('.close-chat');
    const emojiBtn = document.getElementById('emojiBtn');
    const emojiPicker = document.getElementById('emojiPicker');
    const chatText = document.getElementById('chatText');
    
    // Chat button click handler
    chatBtn.addEventListener('click', () => {
      if (chatbox.style.display === 'none') {
        chatbox.style.display = 'flex';
        chatBtn.classList.add('active');
        chatText.focus();
      } else {
        chatbox.style.display = 'none';
        chatBtn.classList.remove('active');
      }
    });
    
    // Close chat panel
    closeChat.addEventListener('click', () => {
      chatbox.style.display = 'none';
      chatBtn.classList.remove('active');
    });
    
    // Emoji button click handler
    emojiBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      emojiPicker.style.display = emojiPicker.style.display === 'flex' ? 'none' : 'flex';
    });
    
    // Initialize emoji picker
    initializeEmojiPicker();
    
    // Close emoji picker when clicking outside
    document.addEventListener('click', (e) => {
      if (!emojiPicker.contains(e.target) && e.target !== emojiBtn) {
        emojiPicker.style.display = 'none';
      }
    });
  }
  
  // Initialize Emoji Picker
  function initializeEmojiPicker() {
    const emojiPicker = document.getElementById('emojiPicker');
    const chatText = document.getElementById('chatText');
    
    const emojis = [
      'üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'üòÇ', 'ü§£', 'üòä', 'üòá',
      'üôÇ', 'üôÉ', 'üòâ', 'üòå', 'üòç', 'ü•∞', 'üòò', 'üòó', 'üòô', 'üòö',
      'üòã', 'üòõ', 'üòù', 'üòú', 'ü§™', 'ü§®', 'üßê', 'ü§ì', 'üòé', 'ü§©',
      'ü•≥', 'üòè', 'üòí', 'üòû', 'üòî', 'üòü', 'üòï', 'üôÅ', '‚òπÔ∏è', 'üò£',
      'üòñ', 'üò´', 'üò©', 'ü•∫', 'üò¢', 'üò≠', 'üò§', 'üò†', 'üò°', 'ü§¨',
      'ü§Ø', 'üò≥', 'ü•µ', 'ü•∂', 'üò±', 'üò®', 'üò∞', 'üò•', 'üòì', 'ü§ó',
      'ü§î', 'ü§≠', 'ü§´', 'ü§•', 'üò∂', 'üòê', 'üòë', 'üò¨', 'üôÑ', 'üòØ',
      'üò¶', 'üòß', 'üòÆ', 'üò≤', 'ü•±', 'üò¥', 'ü§§', 'üò™', 'üòµ', 'ü§ê',
      'ü•¥', 'ü§¢', 'ü§Æ', 'ü§ß', 'üò∑', 'ü§í', 'ü§ï', 'ü§ë', 'ü§†', 'üòà',
      'üëø', 'üëπ', 'üë∫', 'ü§°', 'üí©', 'üëª', 'üíÄ', '‚ò†Ô∏è', 'üëΩ', 'üëæ',
      'ü§ñ', 'üéÉ', 'üò∫', 'üò∏', 'üòπ', 'üòª', 'üòº', 'üòΩ', 'üôÄ', 'üòø',
      'üòæ', 'üëã', 'ü§ö', 'üñêÔ∏è', '‚úã', 'üññ', 'üëå', 'ü§è', '‚úåÔ∏è', 'ü§û',
      'ü§ü', 'ü§ò', 'ü§ô', 'üëà', 'üëâ', 'üëÜ', 'üñï', 'üëá', '‚òùÔ∏è', 'üëç',
      'üëé', '‚úä', 'üëä', 'ü§õ', 'ü§ú', 'üëè', 'üôå', 'üëê', 'ü§≤', 'ü§ù',
      'üôè', '‚úçÔ∏è', 'üíÖ', 'ü§≥', 'üí™', 'ü¶æ', 'ü¶µ', 'ü¶ø', 'ü¶∂', 'üëÇ',
      'ü¶ª', 'üëÉ', 'üß†', 'ü¶∑', 'ü¶¥', 'üëÄ', 'üëÅÔ∏è', 'üëÖ', 'üëÑ', 'üíã',
      'ü©∏', '‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'üñ§', 'ü§ç', 'ü§é',
      'üíî', '‚ù£Ô∏è', 'üíï', 'üíû', 'üíì', 'üíó', 'üíñ', 'üíò', 'üíù', 'üíü'
    ];
    
    emojiPicker.innerHTML = '';
    emojis.forEach(emoji => {
      const emojiElement = document.createElement('span');
      emojiElement.className = 'emoji';
      emojiElement.textContent = emoji;
      emojiElement.addEventListener('click', () => {
        chatText.value += emoji;
        chatText.focus();
        emojiPicker.style.display = 'none';
      });
      emojiPicker.appendChild(emojiElement);
    });
  }

  // Initialize MEMO functionality
  function initializeMemo() {
    // Load any existing transcript
    const savedTranscript = localStorage.getItem(`meeting-${roomId}-transcript`);
    if (savedTranscript) {
      try {
        const data = JSON.parse(savedTranscript);
        meetingTranscript = data.transcript || "";
        updateMemoDisplay();
      } catch (e) {
        console.warn("Failed to load saved transcript:", e);
      }
    }

    // MEMO button click handler
    memoBtn.addEventListener('click', toggleMemoPanel);
    
    // Close memo panel
    document.querySelector('.close-memo').addEventListener('click', () => {
      memoPanel.style.display = 'none';
    });

    // Save memo
    document.getElementById('saveMemo').addEventListener('click', saveFinalSummary);

    // Clear memo
    document.getElementById('clearMemo').addEventListener('click', () => {
      if (confirm("Are you sure you want to clear the meeting memo? This cannot be undone.")) {
        meetingTranscript = "";
        updateMemoDisplay();
        localStorage.removeItem(`meeting-${roomId}-transcript`);
      }
    });
  }

  function toggleMemoPanel() {
    if (memoPanel.style.display === 'none') {
      memoPanel.style.display = 'flex';
      updateMemoDisplay();
    } else {
      memoPanel.style.display = 'none';
    }
  }

  function updateMemoDisplay() {
    if (!meetingTranscript.trim()) {
      memoContent.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No conversation recorded yet. Start speaking or enable avatar mode to capture audio.</div>';
      return;
    }

    const entries = meetingTranscript.split('\n').filter(line => line.trim());
    memoContent.innerHTML = entries.map(entry => {
      const match = entry.match(/\[(.*?)\] (.*?): (.*)/);
      if (match) {
        const [, time, speaker, text] = match;
        return `
          <div class="memo-entry">
            <div class="memo-time">${time}</div>
            <div><span class="memo-speaker">${speaker}:</span> ${text}</div>
          </div>
        `;
      }
      return `<div class="memo-entry">${entry}</div>`;
    }).join('');
    
    memoContent.scrollTop = memoContent.scrollHeight;
  }

  function addToTranscript(speaker, text) {
    const timestamp = new Date().toLocaleTimeString();
    const transcriptEntry = `[${timestamp}] ${speaker}: ${text}\n`;
    meetingTranscript += transcriptEntry;
    
    console.log("üéØ Captured conversation:", transcriptEntry);
    
    // Update memo display if visible
    if (memoPanel.style.display === 'flex') {
      updateMemoDisplay();
    }
    
    // Auto-save transcript every 5 entries
    if (meetingTranscript.split('\n').filter(line => line.trim()).length % 5 === 0) {
      saveTranscriptToLocalStorage();
    }
  }

  // Enhanced speaker identification function
  function identifySpeaker(transcript, myName, peerNames) {
    const transcriptLower = transcript.toLowerCase();
    const myNameLower = myName.toLowerCase();
    
    // Check if it's likely the current user speaking
    if (transcriptLower.includes('i ') || transcriptLower.includes(' my ') || 
        transcriptLower.includes(' me ') || transcriptLower.includes(myNameLower)) {
        return myName;
    }
    
    // Check against known participant names
    for (const [peerId, peerName] of Object.entries(peerNames)) {
        const peerNameLower = peerName.toLowerCase();
        if (transcriptLower.includes(peerNameLower) || 
            transcriptLower.includes('you ') || transcriptLower.includes(' your ')) {
            return peerName;
        }
    }
    
    return "Speaker";
  }

  // Better media initialization
  async function initMedia() {
    try {
        console.log("üé• Initializing camera and microphone...");
        localStream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
                width: { ideal: 1280 },
                height: { ideal: 720 } 
            }, 
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
            }
        });
        
        console.log("‚úÖ Media devices acquired:", {
            video: localStream.getVideoTracks().length,
            audio: localStream.getAudioTracks().length
        });
        
        originalVideoTrack = localStream.getVideoTracks()[0] || null;

        createSmallTile("me", name + " (You)", localStream);
        setMainSpeaker("me", name + " (You)", localStream);

        // Start recording automatically when meeting starts
        console.log("üé§ Starting automatic conversation recording...");
        startAutomaticRecording();

    } catch (err) {
        console.error("‚ùå getUserMedia failed:", err);
        alert("Please allow microphone and camera access to join the meeting. Reload the page after granting permissions.");
    }
  }

  function createSmallTile(id, label, stream, avatarURL) {
    let tile = document.getElementById("tile-" + id);
    if (!tile) {
      tile = document.createElement("div");
      tile.className = "small-tile";
      tile.id = "tile-" + id;
      
      // FIXED: Proper tile click handler for enlargement
      tile.onclick = () => {
        console.log("üñ±Ô∏è Tile clicked:", id, label);
        if (id === "me") {
          setMainSpeaker(id, label, stream, avatarURL);
        } else {
          const peerStream = peerStreams[id];
          setMainSpeaker(id, label, peerStream, avatarURL);
        }
      };
      
      document.getElementById("top-strip").appendChild(tile);
    }

    // Remove active class from all tiles first
    document.querySelectorAll('.small-tile').forEach(t => t.classList.remove('active'));
    
    // Add active class to current tile
    tile.classList.add('active');

    if (avatarURL) {
      tile.innerHTML = `<img src="${avatarURL}"><div class="name-label">${label}</div>`;
    } else if (stream) {
      tile.innerHTML = `<video playsinline autoplay ${id === "me" ? "muted" : ""}></video><div class="name-label">${label}</div>`;
      const vid = tile.querySelector("video");
      try {
        vid.srcObject = stream;
        vid.play().catch(e => console.log("Video play prevented:", e));
      } catch (err) {
        console.warn("Failed to set srcObject on small tile video:", err);
      }
    } else {
      tile.innerHTML = `<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:#999">No video</div><div class="name-label">${label}</div>`;
    }
  }

  // FIXED: Enhanced setMainSpeaker function
  function setMainSpeaker(id, label, stream, avatar) {
    console.log("üéØ Setting main speaker:", id, label);
    currentMainSpeaker = id;
    const main = document.getElementById("main-speaker");
    const mainSpeakerName = document.getElementById("mainSpeakerName");
    
    // Clear main speaker area
    main.innerHTML = '';
    
    if (avatar) {
      main.innerHTML = `<img src="${avatar}"><div class="name-label">${label}</div>`;
      mainSpeakerName.textContent = label;
    } else if (stream) {
      main.innerHTML = `<video playsinline autoplay ${id === "me" ? "muted" : ""}></video><div class="name-label">${label}</div>`;
      mainSpeakerName.textContent = label;
      const vid = main.querySelector("video");
      try {
        vid.srcObject = stream;
        vid.play().catch(e => console.log("Main video play prevented:", e));
      } catch (err) {
        console.warn("Failed to set srcObject on main video:", err);
      }
    } else {
      main.innerHTML = `<div style="width:80%;height:60%;display:flex;align-items:center;justify-content:center;color:#999;font-size:18px;">No active video</div><div class="name-label">${label}</div>`;
      mainSpeakerName.textContent = label;
    }

    // Update active tile highlighting
    document.querySelectorAll('.small-tile').forEach(t => t.classList.remove('active'));
    const activeTile = document.getElementById("tile-" + id);
    if (activeTile) {
      activeTile.classList.add('active');
      console.log("‚úÖ Active tile set:", id);
    }
  }

  // Stable speech recognition with better error handling
  function startAutomaticRecording() {
      if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
          console.warn("SpeechRecognition API not supported in this browser");
          memoBtn.innerHTML = '<span>üìù</span><span>MEMO (No Audio)</span>';
          return null;
      }

      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognition = new SpeechRecognition();
      
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = 'en-US';
      recognition.maxAlternatives = 1;

      let restartTimeout;
      let errorCount = 0;
      const MAX_ERROR_COUNT = 5;

      recognition.onstart = () => {
          console.log("üé§ AUTOMATIC RECORDING STARTED - Capturing ALL conversations");
          isRecording = true;
          recordingIndicator.style.display = 'flex';
          memoBtn.classList.add('recording');
          memoBtn.innerHTML = '<span>üî¥</span><span>RECORDING ALL</span>';
          errorCount = 0;
          
          const timestamp = new Date().toLocaleTimeString();
          meetingTranscript += `[${timestamp}] SYSTEM: Started recording all conversations\n`;
          updateMemoDisplay();
      };

      recognition.onresult = (event) => {
          let finalTranscript = '';
          
          for (let i = event.resultIndex; i < event.results.length; i++) {
              if (event.results[i].isFinal) {
                  finalTranscript += event.results[i][0].transcript + ' ';
              }
          }
          
          if (finalTranscript.trim()) {
              let speaker = identifySpeaker(finalTranscript, name, peerNames);
              
              const timestamp = new Date().toLocaleTimeString();
              const transcriptEntry = `[${timestamp}] ${speaker}: ${finalTranscript.trim()}\n`;
              meetingTranscript += transcriptEntry;
              
              console.log("üéØ CAPTURED CONVERSATION:", transcriptEntry);
              
              if (memoPanel.style.display === 'flex') {
                  updateMemoDisplay();
              }
              
              saveTranscriptToLocalStorage();
          }
      };

      recognition.onerror = (event) => {
          console.error('Speech recognition error:', event.error);
          errorCount++;
          
          clearTimeout(restartTimeout);
          
          if (event.error === 'no-speech') {
              console.log("üîá No speech detected - normal during silence");
              errorCount = Math.max(0, errorCount - 1);
          } else if (event.error === 'audio-capture') {
              console.error("üé§ Audio capture error - check microphone permissions");
          } else if (event.error === 'not-allowed') {
              console.error("üö´ Microphone access denied");
              stopSpeechRecognition();
              return;
          }
          
          if (errorCount >= MAX_ERROR_COUNT) {
              console.error("‚ùå Too many speech recognition errors, stopping");
              stopSpeechRecognition();
              return;
          }
          
          const restartDelay = Math.min(1000 * errorCount, 5000);
          console.log(`üîÑ Restarting speech recognition in ${restartDelay}ms (error count: ${errorCount})`);
          
          restartTimeout = setTimeout(() => {
              if (isRecording) {
                  try {
                      recognition.start();
                  } catch (e) {
                      console.warn("Could not restart recognition:", e);
                  }
              }
          }, restartDelay);
      };

      recognition.onend = () => {
          console.log("üé§ Speech recognition ended");
          clearTimeout(restartTimeout);
          
          if (isRecording && errorCount < MAX_ERROR_COUNT) {
              console.log("üîÑ Auto-restarting speech recognition");
              restartTimeout = setTimeout(() => {
                  if (isRecording) {
                      try {
                          recognition.start();
                      } catch (e) {
                          console.warn("Could not restart recognition after end:", e);
                      }
                  }
              }, 1000);
          }
      };

      try {
          recognition.start();
          console.log("‚úÖ Speech recognition started successfully");
          return recognition;
      } catch (e) {
          console.error("‚ùå Failed to start speech recognition:", e);
          return null;
      }
  }

  function stopSpeechRecognition() {
    if (recognition) {
      isRecording = false;
      recordingIndicator.style.display = 'none';
      memoBtn.classList.remove('recording');
      memoBtn.innerHTML = '<span>üìù</span><span>MEMO</span>';
      try {
        recognition.stop();
      } catch (e) {
        console.warn("Error stopping recognition:", e);
      }
      recognition = null;
    }
  }

  function saveTranscriptToLocalStorage() {
    const meetingData = {
      transcript: meetingTranscript,
      roomId: roomId,
      timestamp: new Date().toISOString(),
      participants: Object.values(peerNames).concat(name)
    };
    
    localStorage.setItem(`meeting-${roomId}-transcript`, JSON.stringify(meetingData));
    console.log("üíæ Transcript auto-saved locally");
  }

  async function saveFinalSummary() {
    if (!meetingTranscript.trim()) {
      alert("No conversation recorded yet.");
      return;
    }

    try {
      await window.saveSummaryToSupabase(roomId, meetingTranscript, userEmail);
      
      const response = await fetch('/save-summary', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          meetingId: roomId,
          transcript: meetingTranscript,
          userEmail: userEmail
        })
      });

      if (response.ok) {
        console.log("‚úÖ Meeting summary saved successfully");
        const result = await response.json();
        
        localStorage.removeItem(`meeting-${roomId}-transcript`);
        
        alert(`‚úÖ Meeting memo saved successfully!\n\nSummary has been saved to your history.`);
      } else {
        console.error("Failed to save summary to server");
        alert("Failed to save memo. Please try again.");
      }
    } catch (error) {
      console.error("Error saving summary:", error);
      saveTranscriptToLocalStorage();
      alert("Memo saved locally. There was an issue saving to the server.");
    }
  }

  // FIXED: Enhanced WebRTC Connection with proper track handling
  function createPeerConnection(peerId) {
      console.log(`üîó Creating peer connection for: ${peerId}`);
      
      const pc = new RTCPeerConnection({
          iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:stun1.l.google.com:19302" },
              { urls: "stun:stun2.l.google.com:19302" }
          ]
      });

      // Add ALL local tracks to the connection
      if (localStream) {
          localStream.getTracks().forEach(track => {
              console.log(`üéØ Adding ${track.kind} track to peer:`, peerId);
              try { 
                  pc.addTrack(track, localStream); 
                  console.log(`‚úÖ Added ${track.kind} track successfully`);
              } catch(e){ 
                  console.warn(`‚ùå addTrack failed for ${track.kind}:`, e);
              }
          });
      }

      // Better track handling
      pc.ontrack = (event) => {
          console.log("üé• Received remote track from peer:", peerId, event.track.kind);
          
          if (event.streams && event.streams[0]) {
              const remoteStream = event.streams[0];
              peerStreams[peerId] = remoteStream;
              
              const label = peerNames[peerId] || "User";
              
              console.log(`‚úÖ Remote ${event.track.kind} track added for ${label}`);

              // Display remote video
              createSmallTile(peerId, label, remoteStream);
              
              // Auto-play the remote video with audio
              setTimeout(() => {
                  const videoElement = document.querySelector(`#tile-${peerId} video`);
                  if (videoElement) {
                      videoElement.muted = false;
                      videoElement.play().catch(e => console.log("Auto-play prevented:", e));
                      console.log(`‚ñ∂Ô∏è Playing remote video for ${label}`);
                  }
              }, 500);
          }
      };

      pc.onicecandidate = (event) => {
          if (event.candidate) {
              console.log("‚ùÑÔ∏è Sending ICE candidate to:", peerId);
              socket.emit("webrtc-ice-candidate", { 
                  to: peerId, 
                  candidate: event.candidate 
              });
          }
      };

      pc.onconnectionstatechange = () => {
          console.log(`üîó Peer ${peerId} connection state:`, pc.connectionState);
          
          if (['disconnected', 'failed', 'closed'].includes(pc.connectionState)) {
              console.log(`‚ùå Peer ${peerId} disconnected`);
              cleanupPeer(peerId);
          }
          
          if (pc.connectionState === 'connected') {
              console.log(`‚úÖ Successfully connected to peer: ${peerId}`);
          }
      };

      peers[peerId] = pc;
      return pc;
  }

  function cleanupPeer(peerId) {
    const tile = document.getElementById('tile-' + peerId);
    if (tile) tile.remove();
    
    if (peers[peerId]) {
      try { 
        peers[peerId].close(); 
      } catch(e){}
      delete peers[peerId];
    }
    
    delete peerStreams[peerId];
    delete peerNames[peerId];
    
    if (currentMainSpeaker === peerId) {
      const remainingPeers = Object.keys(peerStreams);
      if (remainingPeers.length > 0) {
        const newMain = remainingPeers[0];
        setMainSpeaker(newMain, peerNames[newMain], peerStreams[newMain]);
      } else {
        setMainSpeaker("me", name + " (You)", localStream);
      }
    }
    
    console.log("Peer connection closed/removed:", peerId);
  }

  // FIXED: Improved Peer Calling
  async function callPeer(peerId) {
      if (peers[peerId]) {
          console.log("Already connected to peer:", peerId);
          return;
      }
      
      console.log(`üìû Initiating call to peer: ${peerId}`);
      const pc = createPeerConnection(peerId);
      
      try {
          const offer = await pc.createOffer({
              offerToReceiveAudio: true,
              offerToReceiveVideo: true
          });
          
          await pc.setLocalDescription(offer);
          
          console.log(`üì® Sending WebRTC offer to: ${peerId}`);
          socket.emit("webrtc-offer", { 
              to: peerId, 
              sdp: offer 
          });
          
      } catch (err) {
          console.error("‚ùå callPeer error:", err);
      }
  }

  // FIXED: Better Socket Event Handling
  socket.on("connect", async () => {
      console.log("‚úÖ Socket connected:", socket.id);
      await initMedia();
      socket.emit("join-room", { roomId, name });
      console.log("üì® Joined room:", roomId);
  });

  socket.on("existing-peers", async ({ peers: existing }) => {
      console.log("üë• Existing peers received:", existing);
      if (!existing || !existing.length) {
          console.log("‚ÑπÔ∏è No existing peers in room - waiting for others to join");
          return;
      }
      
      console.log(`üîó Connecting to ${existing.length} existing peers`);
      
      for (const peerInfo of existing) {
          const peerId = peerInfo.peerId;
          const peerName = peerInfo.name || "User";
          
          if (peerId && peerId !== socket.id) {
              console.log(`üîó Establishing connection with: ${peerId} (${peerName})`);
              peerNames[peerId] = peerName;
              await new Promise(resolve => setTimeout(resolve, 100));
              await callPeer(peerId);
          }
      }
  });

  socket.on("peer-joined", ({ peerId, name: peerName }) => {
      console.log('üëã NEW PEER JOINED:', peerId, peerName);
      peerNames[peerId] = peerName || "User";
      
      console.log(`üîó Initiating call to new peer: ${peerId}`);
      setTimeout(() => {
          callPeer(peerId);
      }, 500);
  });

  socket.on("webrtc-offer", async ({ from, sdp }) => {
      console.log("üì® Received offer from:", from);
      const pc = createPeerConnection(from);

      if (localStream) {
          localStream.getTracks().forEach(track => {
              try {
                  pc.addTrack(track, localStream);
                  console.log(`‚úÖ Added ${track.kind} track for incoming call`);
              } catch(e) {
                  console.warn(`Failed to add ${track.kind} track:`, e);
              }
          });
      }

      try {
          await pc.setRemoteDescription(new RTCSessionDescription(sdp));
          const answer = await pc.createAnswer({
              offerToReceiveAudio: true,
              offerToReceiveVideo: true
          });
          await pc.setLocalDescription(answer);
          socket.emit("webrtc-answer", { 
              to: from, 
              sdp: answer 
          });
          console.log("üì® Sent answer to:", from);
      } catch (err) {
          console.error("webrtc-offer handling failed:", err);
      }
  });

  socket.on("webrtc-answer", async ({ from, sdp }) => {
      console.log("üì® Received answer from:", from);
      const pc = peers[from];
      if (pc) {
          try { 
              await pc.setRemoteDescription(new RTCSessionDescription(sdp)); 
              console.log("‚úÖ Remote description set for:", from);
          } catch (err) { 
              console.error("setRemoteDescription failed:", err); 
          }
      }
  });

  socket.on("webrtc-ice-candidate", async ({ from, candidate }) => {
      const pc = peers[from];
      if (pc && candidate) {
          try { 
              await pc.addIceCandidate(new RTCIceCandidate(candidate)); 
              console.log("‚úÖ Added ICE candidate from:", from);
          } catch (err) { 
              console.warn("addIceCandidate failed", err); 
          }
      }
  });

  socket.on("peer-avatar", ({ peerId, avatar, name: peerName }) => {
      console.log("üîÑ Received avatar update from:", peerId, peerName);
      const label = (peerName || peerNames[peerId] || "User") + " (Avatar)";
      createSmallTile(peerId, label, null, avatar);
      
      if (currentMainSpeaker === peerId) {
          setMainSpeaker(peerId, label, null, avatar);
      }
  });

  socket.on("peer-left", ({ peerId, name }) => {
      console.log(`üëã Peer left: ${name} (${peerId})`);
      cleanupPeer(peerId);
  });

  socket.on("avatar-off", ({ peerId, name }) => {
      console.log("üîÑ Received avatar off from:", peerId);
      const stream = peerStreams[peerId];
      createSmallTile(peerId, name || "User", stream);
      
      if (currentMainSpeaker === peerId) {
          setMainSpeaker(peerId, name || "User", stream);
      }
  });

  // Enhanced Chat functionality with socket
  const chatMessages = document.getElementById("chat-messages");
  const chatInput = document.getElementById("chatText");
  const sendChat = document.getElementById("sendChat");
  let chatHistory = JSON.parse(localStorage.getItem(`chat-${roomId}`)) || [];

  // Load chat history
  chatHistory.forEach(msg => {
    const d = document.createElement("div");
    d.className = "chat-message";
    d.innerHTML = `
      <div class="chat-sender">${msg.name} <span class="chat-time">${new Date(msg.timestamp).toLocaleTimeString()}</span></div>
      <div>${msg.message}</div>
    `;
    chatMessages.appendChild(d);
  });
  chatMessages.scrollTop = chatMessages.scrollHeight;

  // Send chat message
  function sendChatMessage() {
    const message = chatInput.value.trim();
    if (!message) return;
    
    socket.emit("chat-message", { roomId, name, message });
    chatInput.value = "";
    chatInput.focus();
  }

  sendChat.addEventListener('click', sendChatMessage);
  chatInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') sendChatMessage();
  });

  // Receive chat messages
  socket.on("chat-message", ({ name: sender, message, timestamp }) => {
    const chatItem = { name: sender, message, timestamp: timestamp || Date.now() };
    chatHistory.push(chatItem);
    
    if (chatHistory.length > 100) {
      chatHistory = chatHistory.slice(-100);
    }
    
    localStorage.setItem(`chat-${roomId}`, JSON.stringify(chatHistory));
    
    const chatTimestamp = new Date().toLocaleTimeString();
    const chatTranscriptEntry = `[${chatTimestamp}] [CHAT] ${sender}: ${message}\n`;
    meetingTranscript += chatTranscriptEntry;
    
    const d = document.createElement("div");
    d.className = "chat-message";
    d.innerHTML = `
      <div class="chat-sender">${sender} <span class="chat-time">${new Date(timestamp).toLocaleTimeString()}</span></div>
      <div>${message}</div>
    `;
    chatMessages.appendChild(d);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Show notification if chat is closed
    const chatbox = document.getElementById('chatbox');
    if (chatbox.style.display === 'none') {
      const chatBtn = document.getElementById('chatBtn');
      chatBtn.style.animation = 'pulse 1s 3';
      setTimeout(() => {
        chatBtn.style.animation = '';
      }, 3000);
    }
  });

  // Control buttons
  document.getElementById("leaveBtn").onclick = async () => {
    if (meetingTranscript.trim()) {
      await saveFinalSummary();
    }
    
    socket.emit("leave-meeting", { roomId, name });
    
    stopSpeechRecognition();
    
    Object.values(peers).forEach(pc => { 
      try { pc.close(); } catch(e){} 
    });
    
    if (localStream) {
      localStream.getTracks().forEach(track => { 
        try { track.stop(); } catch(e){} 
      });
    }
    
    window.location.href = "/index.html";
  };

  document.getElementById("muteBtn").onclick = () => {
    if (!localStream) return;
    const audioTrack = localStream.getAudioTracks()[0];
    if (audioTrack) {
      audioTrack.enabled = !audioTrack.enabled;
      document.getElementById("muteBtn").innerHTML = 
        audioTrack.enabled ? '<span>üé§</span><span class="btn-label">Mute</span>' : '<span>üîá</span><span class="btn-label">Unmute</span>';
      document.getElementById("muteBtn").classList.toggle('active', !audioTrack.enabled);
    }
  };

  document.getElementById("videoBtn").onclick = () => {
    if (!localStream) return;
    const videoTrack = localStream.getVideoTracks()[0];
    if (videoTrack) {
      videoTrack.enabled = !videoTrack.enabled;
      document.getElementById("videoBtn").innerHTML = 
        videoTrack.enabled ? '<span>üì∑</span><span class="btn-label">Video</span>' : '<span>üìπ</span><span class="btn-label">Start Video</span>';
      document.getElementById("videoBtn").classList.toggle('active', !videoTrack.enabled);
    }
  };

  document.getElementById("screenBtn").onclick = async () => {
    try {
      const screenStream = await navigator.mediaDevices.getDisplayMedia({ 
        video: true,
        audio: true 
      });
      
      const screenVideoTrack = screenStream.getVideoTracks()[0];
      
      for (const pc of Object.values(peers)) {
        const sender = pc.getSenders().find(s => s.track && s.track.kind === "video");
        if (sender) {
          try { 
            await sender.replaceTrack(screenVideoTrack); 
          } catch(e){ 
            console.warn("replaceTrack screen failed", e); 
          }
        }
      }

      setMainSpeaker("me", name + " (Sharing Screen)", screenStream);

      screenVideoTrack.onended = async () => {
        for (const pc of Object.values(peers)) {
          const sender = pc.getSenders().find(s => s.track && s.track.kind === "video");
          if (sender && originalVideoTrack) {
            try { 
              await sender.replaceTrack(originalVideoTrack); 
            } catch(e){ 
              console.warn("restore track failed", e); 
            }
          }
        }
        setMainSpeaker("me", name + " (You)", localStream);
      };

    } catch(e) {
      console.warn("Screen share canceled or failed:", e);
    }
  };

  // FIXED: Avatar functionality with toggle
  let avatarStream = null;
  let avatarVideoTrack = null;

  document.getElementById("avatarBtn").onclick = async () => {
    const savedAvatar = localStorage.getItem('userAvatar');
    
    if (avatarMode) {
        // If avatar is already enabled, disable it
        await disableAvatar();
    } else if (savedAvatar) {
        // If we have a saved avatar, enable it
        try {
            await enableAvatar(savedAvatar);
        } catch (error) {
            console.error("Failed to enable avatar:", error);
            // If enabling fails, redirect to avatar selection
            redirectToAvatarSelection();
        }
    } else {
        // No avatar selected, redirect to selection
        redirectToAvatarSelection();
    }
  };

  function redirectToAvatarSelection() {
    console.log("üöÄ Redirecting to avatar selection page");
    const params = new URLSearchParams(window.location.search);
    const roomId = params.get("room") || "default";
    const name = user.displayName || "User";
    
    const avatarUrl = `avatar.html?room=${roomId}&name=${name}`;
    console.log("üéØ Redirecting to:", avatarUrl);
    
    window.location.href = avatarUrl;
  }

  // FIXED: Enable avatar with working video replacement
  async function enableAvatar(avatarURL) {
    try {
        console.log("üîÑ Enabling avatar:", avatarURL);
        avatarMode = true;
        
        // Validate avatar URL
        let finalAvatarURL = avatarURL;
        if (!avatarURL.startsWith('data:') && !avatarURL.startsWith('http')) {
            console.warn("‚ùå Invalid avatar URL, using fallback");
            finalAvatarURL = "https://cdn-icons-png.flaticon.com/512/4333/4333609.png";
        }
        
        // Create avatar stream from image
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = 640; 
        canvas.height = 480;
        
        const img = new Image();
        img.crossOrigin = "anonymous";
        
        return new Promise((resolve, reject) => {
            img.onload = async () => {
                try {
                    console.log("‚úÖ Avatar image loaded successfully");
                    
                    // Draw avatar on canvas
                    ctx.fillStyle = "#1a1a1a";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const scale = Math.min(canvas.width / img.width, canvas.height / img.height) * 0.8;
                    const x = (canvas.width - img.width * scale) / 2;
                    const y = (canvas.height - img.height * scale) / 2;
                    
                    ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
                    
                    // Create stream from canvas
                    avatarStream = canvas.captureStream(30); // 30 FPS
                    avatarVideoTrack = avatarStream.getVideoTracks()[0];
                    
                    if (!avatarVideoTrack) {
                        throw new Error("Failed to create video track from canvas");
                    }

                    // FIXED: Replace video track in all peer connections
                    let replaceCount = 0;
                    const peerIds = Object.keys(peers);
                    
                    console.log(`üîÑ Replacing video tracks for ${peerIds.length} peers`);
                    
                    for (const peerId of peerIds) {
                        const pc = peers[peerId];
                        const senders = pc.getSenders();
                        const videoSender = senders.find(s => s.track && s.track.kind === "video");
                        
                        if (videoSender) {
                            try { 
                                await videoSender.replaceTrack(avatarVideoTrack);
                                replaceCount++;
                                console.log("‚úÖ Replaced video track for peer:", peerId);
                            } catch(e){ 
                                console.warn("Replace track failed for peer", peerId, e); 
                            }
                        }
                    }
                    
                    console.log(`‚úÖ Successfully replaced tracks for ${replaceCount} peers`);

                    // FIXED: Update local display to show avatar
                    createSmallTile("me", name + " (Avatar)", null, finalAvatarURL);
                    if (currentMainSpeaker === "me") {
                        setMainSpeaker("me", name + " (Avatar)", null, finalAvatarURL);
                    }
                    
                    // Update button to show disable state
                    document.getElementById('avatarBtn').innerHTML = '<span>üë§</span><span class="btn-label">Disable Avatar</span>';
                    document.getElementById('avatarBtn').classList.add('active');
                    
                    // Notify other participants
                    socket.emit("set-avatar", { roomId, avatar: finalAvatarURL, name });
                    
                    console.log("‚úÖ Avatar mode enabled successfully");
                    resolve();
                    
                } catch (error) {
                    console.error("‚ùå Error in avatar setup:", error);
                    reject(error);
                }
            };
            
            img.onerror = () => {
                console.error("‚ùå Failed to load avatar image:", finalAvatarURL);
                const fallbackAvatar = "https://cdn-icons-png.flaticon.com/512/4333/4333609.png";
                console.log("üîÑ Trying fallback avatar:", fallbackAvatar);
                img.src = fallbackAvatar;
            };
            
            console.log("üì• Loading avatar image:", finalAvatarURL);
            img.src = finalAvatarURL;
            
            // Set timeout for image loading
            setTimeout(() => {
                if (!img.complete) {
                    console.warn("‚è∞ Avatar image loading timeout, using fallback");
                    img.onerror = null;
                    img.src = "https://cdn-icons-png.flaticon.com/512/4333/4333609.png";
                }
            }, 3000);
        });
        
    } catch (error) {
        console.error("‚ùå Failed to enable avatar:", error);
        avatarMode = false;
        alert("Failed to enable avatar mode. Please try selecting a different avatar.");
        document.getElementById('avatarBtn').innerHTML = '<span>üßë</span><span class="btn-label">Avatar</span>';
        document.getElementById('avatarBtn').classList.remove('active');
        throw error;
    }
  }

  async function disableAvatar() {
    try {
        console.log("üîÑ Disabling avatar...");
        avatarMode = false;
        
        if (!localStream) {
            console.error("‚ùå No local stream available to restore");
            return;
        }
        
        const originalVideoTracks = localStream.getVideoTracks();
        if (originalVideoTracks.length === 0) {
            console.error("‚ùå No original video track available");
            return;
        }
        
        const originalVideoTrack = originalVideoTracks[0];
        
        // Restore original video track to all peer connections
        let restoreCount = 0;
        for (const peerId of Object.keys(peers)) {
            const pc = peers[peerId];
            const senders = pc.getSenders();
            const videoSender = senders.find(s => s.track && s.track.kind === "video");
            
            if (videoSender && originalVideoTrack) {
                try { 
                    await videoSender.replaceTrack(originalVideoTrack);
                    restoreCount++;
                    console.log("‚úÖ Restored original video track for peer:", peerId);
                } catch(e){ 
                    console.warn("Restore track failed for peer", peerId, e); 
                }
            }
        }

        console.log(`‚úÖ Successfully restored tracks for ${restoreCount} peers`);

        // Update local display to show normal video
        createSmallTile("me", name + " (You)", localStream);
        if (currentMainSpeaker === "me") {
            setMainSpeaker("me", name + " (You)", localStream);
        }
        
        // Update button to show enable state
        document.getElementById('avatarBtn').innerHTML = '<span>üßë</span><span class="btn-label">Avatar</span>';
        document.getElementById('avatarBtn').classList.remove('active');
        
        // Notify other participants
        socket.emit("avatar-off", { roomId, name });
        
        console.log("‚úÖ Avatar mode disabled successfully");
        
    } catch (error) {
        console.error("‚ùå Failed to disable avatar:", error);
    }
  }

  // FIXED: Check if we should auto-enable avatar when page loads
  function checkAutoEnableAvatar() {
    const params = new URLSearchParams(window.location.search);
    const useAvatar = params.get('useAvatar');
    const savedAvatar = localStorage.getItem('userAvatar');
    
    if (useAvatar === 'true' && savedAvatar && !avatarMode) {
        console.log("üîÑ Auto-enabling avatar from redirect...");
        // Wait a bit for media to initialize, then enable avatar
        setTimeout(async () => {
            try {
                await enableAvatar(savedAvatar);
                // Remove the parameter from URL without reloading
                const newUrl = window.location.pathname + '?room=' + roomId;
                window.history.replaceState({}, '', newUrl);
            } catch (error) {
                console.error("‚ùå Auto-enable avatar failed:", error);
                // Remove the parameter even if failed
                const newUrl = window.location.pathname + '?room=' + roomId;
                window.history.replaceState({}, '', newUrl);
            }
        }, 2000);
    }
  }

  // Recording button functionality
  document.getElementById("recordBtn").onclick = async () => {
    alert("Recording feature will be implemented in the next update!");
  };

  // Handle page unload
  window.addEventListener('beforeunload', () => {
    if (meetingTranscript.trim()) {
      saveTranscriptToLocalStorage();
    }
    socket.emit("leave-meeting", { roomId, name });
  });

  // Initialize the meeting
  initializeChat();
  initializeMemo();
  checkAutoEnableAvatar(); // Check if we need to auto-enable avatar
}
</script>
</body>
</html>